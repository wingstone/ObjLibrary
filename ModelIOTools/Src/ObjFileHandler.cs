using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using MathLibrary;
using GeometryTools;

namespace ModelIOTools
{
    /// <summary>
    /// Handles reading and writing OBJ file format for mesh data.
    /// </summary>
    public class ObjFileHandler
    {
        /// <summary>
        /// Exports a mesh to OBJ file format.
        /// </summary>
        /// <param name="mesh">Mesh to export.</param>
        /// <param name="filePath">Output file path.</param>
        public static void WriteMesh(Mesh mesh, string filePath)
        {
            if (mesh == null)
                throw new ArgumentNullException(nameof(mesh));

            using (var writer = new StreamWriter(filePath))
            {
                var sb = new StringBuilder();
                writer.WriteLine("# Generated by ModelIOTools ObjFileHandler");
                
                if (mesh != null)
                {
                    // Write vertices
                    if (mesh.vertices != null)
                    {
                        foreach (Vector3 v in mesh.vertices)
                            sb.AppendFormat("v {0} {1} {2}\n", v.x, v.y, v.z);
                        sb.AppendLine();
                    }

                    // Write normals
                    if (mesh.normals != null)
                    {
                        foreach (Vector3 n in mesh.normals)
                            sb.AppendFormat("vn {0} {1} {2}\n", n.x, n.y, n.z);
                        sb.AppendLine();
                    }

                    // Write texture coordinates
                    if (mesh.uvs0 != null)
                    {
                        foreach (Vector2 uv in mesh.uvs0)
                            sb.AppendFormat("vt {0} {1}\n", uv.x, uv.y);
                        sb.AppendLine();
                    }

                    // Write faces
                    if (mesh.triangles != null)
                    {
                        bool hasNormals = mesh.normals != null;
                        bool hasUVs = mesh.uvs0 != null;

                        for (int i = 0; i < mesh.triangles.Length; i += 3)
                        {
                            // OBJ format uses 1-based indices
                            int v0 = mesh.triangles[i] + 1;
                            int v1 = mesh.triangles[i + 1] + 1;
                            int v2 = mesh.triangles[i + 2] + 1;

                            if (hasUVs && hasNormals)
                                sb.AppendFormat("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n", v0, v1, v2);
                            else if (hasUVs)
                                sb.AppendFormat("f {0}/{0} {1}/{1} {2}/{2}\n", v0, v1, v2);
                            else if (hasNormals)
                                sb.AppendFormat("f {0}//{0} {1}//{1} {2}//{2}\n", v0, v1, v2);
                            else
                                sb.AppendFormat("f {0} {1} {2}\n", v0, v1, v2);
                        }
                        sb.AppendLine();
                    }
                }

                writer.Write(sb.ToString());
            }
        }

        /// <summary>
        /// Reads a mesh from OBJ file format.
        /// </summary>
        /// <param name="filePath">Path to the OBJ file.</param>
        /// <returns>Mesh loaded from the file.</returns>
        public static Mesh ReadMesh(string filePath)
        {
            if (!File.Exists(filePath))
                throw new FileNotFoundException($"OBJ file not found: {filePath}");

            var mesh = new Mesh();
            var vertices = new List<Vector3>();
            var normals = new List<Vector3>();
            var uvs = new List<Vector2>();
            var triangles = new List<int>();

            using (var reader = new StreamReader(filePath))
            {
                string? line;
                while ((line = reader.ReadLine()) != null)
                {
                    line = line.Trim();

                    // Skip empty lines and comments
                    if (string.IsNullOrEmpty(line) || line.StartsWith("#"))
                        continue;

                    var parts = line.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
                    if (parts.Length == 0)
                        continue;

                    switch (parts[0])
                    {
                        case "v": // Vertex
                            if (parts.Length >= 4)
                            {
                                vertices.Add(new Vector3(
                                    float.Parse(parts[1]),
                                    float.Parse(parts[2]),
                                    float.Parse(parts[3])
                                ));
                            }
                            break;

                        case "vn": // Normal
                            if (parts.Length >= 4)
                            {
                                normals.Add(new Vector3(
                                    float.Parse(parts[1]),
                                    float.Parse(parts[2]),
                                    float.Parse(parts[3])
                                ));
                            }
                            break;

                        case "vt": // Texture coordinate
                            if (parts.Length >= 3)
                            {
                                uvs.Add(new Vector2(
                                    float.Parse(parts[1]),
                                    float.Parse(parts[2])
                                ));
                            }
                            break;

                        case "f": // Face
                            ParseFace(parts, triangles);
                            break;
                    }
                }
            }

            mesh.vertices = vertices.Count > 0 ? vertices.ToArray() : null;
            mesh.normals = normals.Count > 0 ? normals.ToArray() : null;
            mesh.uvs0 = uvs.Count > 0 ? uvs.ToArray() : null;
            mesh.triangles = triangles.Count > 0 ? triangles.ToArray() : null;

            return mesh;
        }

        /// <summary>
        /// Parses face data from OBJ format.
        /// </summary>
        private static void ParseFace(string[] parts, List<int> triangles)
        {
            // OBJ faces can have 3+ vertices, we'll triangulate if needed
            var faceVertices = new List<int>();

            for (int i = 1; i < parts.Length; i++)
            {
                var indices = parts[i].Split('/');
                if (indices.Length > 0 && int.TryParse(indices[0], out int vertexIndex))
                {
                    // OBJ uses 1-based indexing, convert to 0-based
                    faceVertices.Add(vertexIndex - 1);
                }
            }

            // Triangulate if we have more than 3 vertices
            if (faceVertices.Count >= 3)
            {
                for (int i = 1; i < faceVertices.Count - 1; i++)
                {
                    triangles.Add(faceVertices[0]);
                    triangles.Add(faceVertices[i]);
                    triangles.Add(faceVertices[i + 1]);
                }
            }
        }
    }
}
